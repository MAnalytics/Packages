
#' @title Plotting the cluster solution
#' @description Function to plot the clusters generated by the \code{\link{akmedoids.clust}} function
#' @param clustr A vector of cluster labels (e.g. from an output of \code{\link{akmedoids.clust}})
#' @param traj The matrix or data.frame of trajectories from which the cluster solution \code{clustr} is generated.
#' @param id_field Whether the first column of \code{traj} is a unique (id) field. Default: \code{TRUE}.
#' @param y.scaling To set the vertical scales of the cluster panels. Options are: \code{"fixed"}: uses uniform scale for all panels, \code{"free"}: uses variable scales for panels.
#' @examples
#' traj <- gm.crime.sample1
#' print(traj)
#' traj <- missingVal(traj, id_field = TRUE, method = 2, replace_with = 1,
#' fill_zeros = FALSE) #filling the missing values
#' print(traj)
#' traj <- props(traj, id_field = TRUE)
#' clustr <- akmedoids.clust(traj, id_field = TRUE, method = "linear", k = c(3,6))
#' print(plotr(clustr, traj, id_field=TRUE, y.scaling="fixed"))
#' @details Given a matrix or data.frame with some suspected outlier observations, this function identified those observations based on the method chosen and replace all the observations accordingly.
#' @return A plot showing clusters of trajectories, including the mean trajectory of each group.
#' @keywords plot, clusters
#' @rawNamespace import(reshape2, ggplot2)
#' @references \code{Wickham H. (2016). Elegant graphics for Data Analysis. Spring-Verlag New York (2016)}
#' @export

plotr <- function(clustr, traj, id_field=TRUE, y.scaling="fixed"){

  #joining the data with the clusters
  clustr <- data.frame(cbind(traj, clusters=as.character(clustr$optimSolution)))

  #check if 'id_field' is a unique field
  if(id_field==TRUE){
    n_CL <- colnames(clustr)[1]
    col_names <- as.vector(clustr[,1])
    if(!length(col_names)==length(unique(col_names))){
      stop("(: The 'id_field' is not a unique field. Function terminated!!! :)")
    }
  }

  if(id_field==FALSE){
    clustr <- cbind(1:nrow(clustr), clustr)  #head(clustr)
  }

  #cluster list
  clusters <- as.vector(clustr[,ncol(clustr)])

  #data
  data_subset <- clustr[,1:(ncol(clustr)-1)] #head(data_subset)
  colnames(data_subset) <- c("code", 1:(ncol(clustr)-2))

  data_subset <- as.data.frame(data_subset) #head(data_subset)

  data.subset.melted <- suppressWarnings(melt(data_subset, id="code"))  #head(data_subset.melted) #length(unique(data_subset$code)) #nrow(data_subset)

  #append cluster list
  data.subset.melted <- cbind(data.subset.melted, rep(clusters, ncol(data_subset)-1))#nrow(data.long.melted)

  ggplot <- aes <- Year <- value <- id <- geom_line <- facet_wrap <- geom_smooth <- theme_minimal <- NULL

  colnames(data.subset.melted) <- c("id","Year","value", "clusters")
  #plot
  if(y.scaling=="fixed"){
    p <- (ggplot(data.subset.melted, aes(x=Year, y=value,
                                         group=id), color="grey") +
            geom_line() +
            stat_summary(fun.y=mean, geom="line", aes(group=clusters), color="black", size=1) +
            facet_wrap(~clusters, scales = "fixed") +
            #geom_smooth(method="lm", aes(group=clusters), color="black", size=1) +
            scale_fill_brewer(palette = "Set1") +
            theme_minimal()) #clusters
  }

  if(y.scaling=="free"){
    p <- (ggplot(data.subset.melted, aes(x=Year, y=value,
                                         group=id)) +

            geom_line() +
            stat_summary(fun.y=mean, geom="line", aes(group=clusters), color="black", size=1) +
            facet_wrap(~clusters, scales = "free") +
            #geom_smooth(method="lm", aes(group=clusters), color="black", size=1) +
            scale_fill_brewer(palette = "Set1") +
            theme_minimal()) #clusters
  }

  return(p)
}
