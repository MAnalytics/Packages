
#' @title Plotting trajectory grouping
#' @description This function can be used to visualise the trajectory groupings generated by the \code{\link{akmedoids.clust}} function, and print out some descriptive statitics of each group.
#' @param clustr [vector (charater)] A vector of cluster membership (labels). For instance, the result extracted from the \code{\link{akmedoids.clust}} function. See the @example.
#' @param traj [matrix (numeric)]: corresponding longitudinal data used to generate \code{clustr} (with rows corresponding to each label of \code{clustr}). For example, the first label of \code{clustr} is the group label of the first row of \code{traj} matrix, and so on.
#' @param id_field [numeric or character] Whether the first column of the \code{traj} is a unique (\code{id}) field. Default: \code{FALSE}. If \code{TRUE} the function recognises the second column as the first time step.
#' @param type [character] plot type. Available options are: \code{"lines"} and "stacked".
#' @param y.scaling [character] works only if \code{type="lines"}. \code{y.scaling} set the vertical scales of the cluster panels. Options are: \code{"fixed"}: uses uniform scale for all panels, \code{"free"}: uses variable scales for panels.
#' @examples
#' traj <- gm.crime.sample1
#' print(traj)
#' traj <- dataImputation(traj, id_field = TRUE, method = 1, replace_with = 1, fill_zeros = FALSE) #filling the missing values
#' print(traj)
#' traj <- props(traj, id_field = TRUE)
#' clustr <- akmedoids.clust(traj, id_field = TRUE, method = "linear", k = c(3,6))
#' clustr <- as.vector(clustr$optimSolution)
#' print(plotr(clustr, traj, id_field=TRUE, type="lines", y.scaling="fixed"))
#' print(plotr(clustr, traj, id_field=TRUE, type="stacked"))
#' @details Given a vector of group membership (labels) and the corresponding data matrix (or data.frame) sorted in corresponding order, this function generates
#' either a line plot of group trajectories (including mean trajectories) or a stacked area chart showing the proportion observation (in each group) of over time. Some useful descriptive statistics of each group are also generated.
#' This plot function is provided to provide basic visualisation of the cluster groups based on a few parameters from the \code{ggplot} library (\code{Wickham H. (2016)}), therefore, for a better control of the plot, we recommend using the ggplot directly.
#' @return A plot showing group trajectories or size.
#' @keywords plot, clusters
#' @rawNamespace import(reshape2, ggplot2)
#' @references \code{Wickham H. (2016). Elegant graphics for Data Analysis. Spring-Verlag New York (2016)}
#' @export

plotr <- function(clustr, traj, id_field=TRUE, type = "lines", y.scaling="fixed"){

  #joining the data with the clusters
  clustr <- data.frame(cbind(traj, clusters=clustr))

  #check if 'id_field' is a unique field
  if(id_field==TRUE){
    n_CL <- colnames(clustr)[1]
    col_names <- as.vector(clustr[,1])
    if(!length(col_names)==length(unique(col_names))){
      stop("(: The 'id_field' is not a unique field. Function terminated!!! :)")
    }
  }

  if(id_field==FALSE){
    clustr <- cbind(1:nrow(clustr), clustr)  #head(clustr)
  }

  #cluster list
  clusters <- as.vector(clustr[,ncol(clustr)])

  data_subset <- clustr[,1:(ncol(clustr)-1)] #head(data_subset)

  data_subset <- as.data.frame(data_subset) #head(data_subset)
  colnames(data_subset) <- c("code", 1:(ncol(data_subset)-1))

  data.subset.melted <- suppressWarnings(melt(data_subset, id="code"))  #head(data_subset.melted)

  #append cluster list
  data.subset.melted <- cbind(data.subset.melted, rep(clusters, ncol(data_subset)-1))#nrow(data.long.melted)

  #some global variables
  ggplot <- aes <- Year <- value <- id <- geom_line <- facet_wrap <- geom_smooth <- theme_minimal <- NULL

  colnames(data.subset.melted) <- c("id","Year","value", "clusters")

  #plot option 1:
  if(type=="lines"){
  if(y.scaling=="fixed"){
    p <- (ggplot(data.subset.melted, aes(x=Year, y=value,
                                             group=id, color=clusters)) +
                geom_line() +
                stat_summary(fun.y=mean, geom="line", aes(group=clusters), color="black", size=1) +
                facet_wrap(~clusters, scales = "fixed") +
                facet_wrap(~clusters) +
                scale_colour_brewer(palette = "Set1")) #clusters
          }

  if(y.scaling=="free"){
    p <- (ggplot(data.subset.melted, aes(x=Year, y=value,
                                         group=id, color=clusters)) +
            geom_line() +
            stat_summary(fun.y=mean, geom="line", aes(group=clusters), color="black", size=1) +
            facet_wrap(~clusters, scales = "free") +
            facet_wrap(~clusters) +
            scale_colour_brewer(palette = "Set1")) #clusters
    }
  }#end of type 1

  #plot option 1:
  if(type=="stacked"){

  #head(data.subset.melted)##
  #use this to calculate percentage (%) change from year 1 to year n
  year_uni <- as.vector(unique(data.subset.melted$Year))
  order_Cluster <- as.vector(unique(data.subset.melted$clusters))
  clusters_uni <- order_Cluster[order(as.vector(unique(data.subset.melted$clusters)))]

  change_ave_yr_ALL <- NULL

  for(q in 1:length(clusters_uni)){#p<-1
    all_clust_list <- data.subset.melted[which(data.subset.melted$clusters==clusters_uni[q]),]
    ave_yr <- NULL
    for(m in 1:length(year_uni)){ #m<-1
      yr_ <- all_clust_list[which(as.vector(all_clust_list$Year)==year_uni[m]),]#all first year data..
      ave_yr <- c(ave_yr, sum(yr_$value))
    }
    change_ave_yr_ALL <- rbind(change_ave_yr_ALL,  ave_yr)
  }

  b_change_ave_yr_ALL  <- change_ave_yr_ALL  #USE THIS FOR THE DESCRIPTIVE COMPUTATION

  change_ave_yr_ALL <- t(change_ave_yr_ALL)
  #----------------------------------------------grp_
  grp.dat<-data.frame(change_ave_yr_ALL,row.names=1:nrow(change_ave_yr_ALL))
  names(grp.dat)<-clusters_uni
  p.dat<-data.frame(Year=row.names(grp.dat),grp.dat,stringsAsFactors=F) #p.dat
  #----------------------------------------------
  p.dat<-melt(p.dat,id='Year')
  p.dat$Year<-as.numeric(p.dat$Year) #head(p.dat)
  class(p.dat$Year)

  p <- ggplot(p.dat,aes(x=Year,y=value)) + theme(legend.position="none")

  p + geom_area(aes(fill=variable), colour = "gray30", position='fill') + #scale_fill_manual(values = colours) +
    scale_x_continuous(breaks=1:nrow(change_ave_yr_ALL), labels=Year) +
    scale_fill_brewer(palette = "Set1") +
    theme_light()
  }

  return(p)

}



