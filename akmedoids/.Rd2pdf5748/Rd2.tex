\documentclass[a4paper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8]{inputenc} % @SET ENCODING@
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `akmedoids'}}
\par\bigskip{\large \today}
\end{center}
\begin{description}
\raggedright{}
\inputencoding{utf8}
\item[Type]\AsIs{Package}
\item[Title]\AsIs{Akmedoids: 'Anchored kmedoids' for longitudinal data clustering}
\item[Version]\AsIs{0.1.0}
\item[Date]\AsIs{2019-02-06}
\item[Author]\AsIs{Monsuru Adepeju [cre, aut], Samuel Langton [aut], Jon Bannister [aut]}
\item[Maintainer]\AsIs{Monsuru Adepeju }\email{monsuurg2010@gmail.com}\AsIs{}
\item[Description]\AsIs{Advances a longitudinal clustering technique ('akmedoids') for grouping trajectories based on the similarities of their long-term trends and determines the optimal solution based on the Calinski-Harabatz criterion. Includes functions to extract descriptive statistics and generate a visualisation of the resulting groups. The package also include a number of other useful functions for exploring and manipulating longitudinal data prior to the clustering process.}
\item[Depends]\AsIs{R (>= 3.5.0)}
\item[License]\AsIs{GPL-2}
\item[Encoding]\AsIs{UTF-8}
\item[LazyData]\AsIs{true}
\item[Imports]\AsIs{kml, devtools, Hmisc, ggplot2, rgdal, base, utils, reshape2, later, Rdpack, longitudinalData}
\item[RoxygenNote]\AsIs{6.1.1}
\item[Suggests]\AsIs{knitr,
rmarkdown,
pander}
\item[VignetteBuilder]\AsIs{knitr}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{akmedoids.clust}{Anchored k-medoids clustering}{akmedoids.clust}
%
\begin{Description}\relax
Given a list of trajectories and a functional method, this function clusters the trajectories into a \code{k} number of groups. If a vector of two numbers is given, the function determines the best solution from those options based on the Calinski-Harabatz criterion.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
akmedoids.clust(traj, id_field = FALSE, method = "linear", k = c(3,6))
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{traj}] [matrix (numeric)]: longitudinal data. Each row represents an individual trajectory (of observations). The columns show the observations at consecutive time steps.

\item[\code{id\_field}] [numeric or character] Whether the first column of the \code{traj} is a unique (\code{id}) field. Default: \code{FALSE}. If \code{TRUE} the function recognises the second column as the first time points.

\item[\code{method}] [character] The parametric initialisation strategy. Currently, the only available method is a \code{linear} method, set as \code{"linear"}. This uses the time-dependent linear regression lines and the resulting groups are order in the order on increasing slopes.

\item[\code{k}] [integer or vector (numeric)] either an exact integer number of clusters, or a vector of length two specifying the minimum and maximum numbers of clusters to be examined from which the best solution will be determined. In either case, the minimum number of clusters is \code{3}. The default is \code{c(3,6)}. The best solution is determined using the Calinski-Harabatz criterion \code{(Calinski T. \& Harabasz J. 1974)}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This function works by first approximating the trajectories based on the chosen parametric forms (e.g. linear), and then partitions the original trajectories based on the form groupings, in similar fashion to k-means clustering \code{(Genolini et al. 2015)}. The key distinction of \code{akmedoids} compared with existing longitudinal approaches is that both the initial starting points as well as the subsequent cluster centers (as the iteration progresses) are based the selection of observations (medoids) as oppose to centroids.
\end{Details}
%
\begin{Value}
The key output is a vector of cluster labels of length equal to the number of trajectories. Each label indicates the group membership of the corresponding trajectory in the \code{traj} object. In addition, a plot of the Calinski-Harabatz scores is shown if a vector of \code{k} is provided.
\end{Value}
%
\begin{References}\relax
\code{1}. Genolini, C. et al. (2015). kml and kml3d: R Packages to Cluster Longitudinal Data. Journal of Statistical Software, 65(4), 1-34. URL http://www.jstatsoft.org/v65/i04/.
\code{2}. Calinski T, Harabasz J (1974) A dendrite method for cluster analysis. Commun Stat 3:1-27.
\code{3}. Genolini, C.et al. (2016) Package ‘longitudinalData’
\end{References}
%
\begin{Examples}
\begin{ExampleCode}
traj <- traj
print(traj)
traj <- dataImputation(traj, id_field = TRUE, method = 2, replace_with = 1, fill_zeros = FALSE)
traj <- props(traj, id_field = TRUE)
print(traj)
output <- akmedoids.clust(traj, id_field = TRUE, method = "linear", k = c(3,6))
print(output)  #type 'as.vector(output$optimSolution)'
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{alphaLabel}{Numerics ids to alphabetical ids}{alphaLabel}
%
\begin{Description}\relax
Function to transform a list of numeric ids to alphabetic ids
\end{Description}
%
\begin{Usage}
\begin{verbatim}
alphaLabel(x)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] A vector of numeric ids
\end{ldescription}
\end{Arguments}
\inputencoding{utf8}
\HeaderA{dataImputation}{Data imputation for longitudinal data}{dataImputation}
%
\begin{Description}\relax
This function fills any missing entries (\code{NA}, \code{Inf}, \code{null}) in a matrix or dataframe, according to a specified method. By default, \code{'0'} is considered a value.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
dataImputation(traj, id_field = FALSE, method = 2, replace_with = 1, fill_zeros = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{traj}] [\code{matrix (numeric)}]: longitudinal data. Each row represents an individual trajectory (of observations). The columns show the observations at consecutive time points.

\item[\code{id\_field}] [numeric or character] Whether the first column of the \code{traj} is a unique (\code{id}) field. Default: \code{FALSE}. If \code{TRUE} the function recognises the second column as the first time step.

\item[\code{method}] [an integer] indicating a method for calculating the missing values. Options are: \code{'1'}: \code{arithmetic} method, and \code{'2'}: \code{regression} method. The default is \code{'1'}: \code{arithmetic} method

\item[\code{replace\_with}] [an integer from 1 to 6] indicating the technique, based on a specified \code{method}, for calculating the missing entries.
\code{'1'}: \code{arithmetic} method, \code{replace\_with} options are: \code{'1'}: Mean value of the corresp column;
\code{'2'}: Minimum value of corresp column; \code{'3'}: Maximum value of corresp column;
\code{'4'}: Mean value of corresp row; \code{'5'}: Minimum value of corresp row,
or \code{'6'}: Maximum value of corresp row. For \code{'2'}: regression method:
the available option for the \code{replace\_with} is: \code{'1'}: \code{linear}.
The regression method fits a linear regression line to a trajectory with missing entry(s)
and estimates the missing data values from the regression line.
Note: only the missing data points derive their new values from the regression line
while the rest of the data points retain their original values. The function terminates if there are
trajectories with only one observation. The default is \code{'1'}: Mean value of the corresp column

\item[\code{fill\_zeros}] [TRUE or FALSE] whether to consider zeros \code{0} as missing values when \code{2: regression} method is used. The default is \code{FALSE}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Given a matrix or data.frame with some missing values indicated by (\code{NA}, \code{Inf}, \code{null}), this function impute the missing value by using either an estimation from the corresponding rows or columns, or to use a regression method to estimate the missing values.
\end{Details}
%
\begin{Value}
A data.frame with missing values (\code{NA}, \code{Inf}, \code{null}) imputed according to the a specified technique.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
traj <- data(traj)
print(traj)
 dataImputation(traj, id_field = TRUE, method = 1, replace_with = 1, fill_zeros = FALSE)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{outlierDetect}{Outlier detection and replacement}{outlierDetect}
%
\begin{Description}\relax
This function identifies outlier observations in the trajectories, and allows users to replace the observations or remove trajectories entirely.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
outlierDetect(traj, id_field = FALSE, method = 1, threshold = 0.95,
count = 1, replace_with = 1)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{traj}] [matrix (numeric)]: longitudinal data. Each row represents an individual trajectory (of observations). The columns show the observations at consecutive time points.

\item[\code{id\_field}] [numeric or character] Whether the first column of the \code{traj} is a unique (\code{id}) field. Default: \code{FALSE}. If \code{TRUE} the function recognises the second column as the first time step.

\item[\code{method}] [integer (numeric)] indicating the method for identifying the outlier. Options are: \code{'1'}: quantile method (\code{default}), and \code{'2'}: manual method. The \code{manual} method requires a user-defined value.

\item[\code{threshold}] [numeric] A cut-off value for outliers. If the \code{method} parameter is set as \code{'1'}:quantile, the \code{threshold} should be a numeric vector of probability between \code{[0,1]}, whilst if the \code{method} is set as \code{'2'}: \code{manual}, the \code{threshold} could be any numeric vector.

\item[\code{count}] [integer (numeric)] indicating the number of observations (in a trajectory) that must exceed the \code{threshold} in order for the trajectory to be considered an \code{outlier}. Default is \code{1}.

\item[\code{replace\_with}] [integer (numeric)] indicating the technique to use for calculating a replacement for an outlier observation. The remaining observations on the row or the column in which the outlier observation is located are used to calculate the replacement.
The replacement options are: \code{'1'}: Mean value of the column, \code{'2'}: Mean value of the row and \code{'3'}: remove the row (trajectory) completely from the data. Default value is the \code{'1'} option.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Given a matrix, this function identifies outliers that exceed the threshold and replaces the outliers with an estimate calculated using the other observations either the rows or the columns in which the outlier observation is located. Option is also provided to remove the trajectories (containing the outlier) from the data.
\end{Details}
%
\begin{Value}
A dataframe with outlier observations replaced or removed.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
traj <- traj
traj <- dataImputation(traj, id_field=TRUE, method = 1, replace_with = 1)
traj <- props(traj, id_field=TRUE)#remove this later
outlierDetect(traj, id_field = TRUE, method = 1, threshold = 0.95,
count = 1, replace_with = 1)
outlierDetect(traj, id_field = TRUE, method = 2, threshold = 15,
count = 4, replace_with = 3)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{population}{sample population (denominator) data}{population}
\keyword{datasets}{population}
%
\begin{Description}\relax
simulated denominator data for two consecutive census years
\end{Description}
%
\begin{Usage}
\begin{verbatim}
population
\end{verbatim}
\end{Usage}
%
\begin{Format}
A matrix
\end{Format}
\inputencoding{utf8}
\HeaderA{props}{Conversion of counts (or rates) to 'Proportion'}{props}
%
\begin{Description}\relax
This function converts counts or rates to proportions.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
props(traj, id_field = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{traj}] [matrix (numeric)]: longitudinal data. Each row represents an individual trajectory (of observations). The columns show the observations at consecutive time points.

\item[\code{id\_field}] [numeric or character] Whether the first column of the \code{traj} is a unique (\code{id}) field. Default: \code{FALSE}. If \code{TRUE} the function recognises the second column as the first time step.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Given a matrix of observations (counts or rates), this function converts each observation to a proportion equivalent to the sum of each column. In other words, each observation is divided by the sum of the column where it is located, i.e. \code{prop = [a cell value] / sum[corresponding column]}
\end{Details}
%
\begin{Value}
A matrix of proportion measures
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
traj <- traj
head(traj) #
traj <- dataImputation(traj, id_field = TRUE, method = 2, replace_with = 1,
fill_zeros = FALSE) #filling the missing values
traj <- props(traj, id_field = TRUE)
print(traj)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{rates}{Conversion of counts to rates}{rates}
%
\begin{Description}\relax
Calculates rates from 'observed' count and a denominator data
\end{Description}
%
\begin{Usage}
\begin{verbatim}
rates(traj, denomin, id_field, multiplier)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{traj}] [matrix (numeric)] longitudinal (e.g. observed count) data (\code{m x n}). Each row represents an individual trajectory (of observations). The columns show the observations at consecutive time steps.

\item[\code{denomin}] [matrix (numeric)] longitudinal (denominator) data of the same column as `traj` (\code{n}).

\item[\code{id\_field}] [numeric or character] Default is \code{TRUE}. The first column of both the `traj` and the `denomin` object must be the unique (\code{id}) field. If \code{FALSE}, the function will terminate. The assumption is that columns of both the \code{traj} and \code{denominat} corresponds. That is, column2, column3, ... represent time points 2, 3, ..., respectively, in each object.

\item[\code{multiplier}] [numeric] A quantify by which to the ratio \code{traj/denomin} is expressed. Default is \code{100}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
The key output is a
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
traj2 <- traj
traj2 <- dataImputation(traj2, id_field = TRUE, method = 2, replace_with = 1, fill_zeros = FALSE)
pop <- population #read denominator data
pop2 <- as.data.frame(matrix(0, nrow(population), ncol(traj)))
colnames(pop2) <- names(traj2)
pop2[,1] <- as.vector(as.character(pop[,1]))
pop2[,4] <- as.vector(as.character(pop[,2]))
pop2[,8] <- as.vector(as.character(pop[,3]))
list_ <- c(2, 3, 5, 6, 7, 9, 10) #vector of missing years
#fill the missing fields with 'NA'
for(u_ in 1:length(list_)){
    pop2[,list_[u_]] <- "NA"
}
#estimate missing fields
pop_imp_result <- dataImputation(pop2, id_field = TRUE, method = 2, replace_with = 1, fill_zeros = FALSE)
#calculate rates i.e. crimes per 200 population
crime_rates <- rates(traj2, denomin=pop_imp_result, id_field=TRUE, multiplier = 200)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{statPrint}{Descriptive (Change) statistics and plots}{statPrint}
\keyword{clusters}{statPrint}
\keyword{plot,}{statPrint}
%
\begin{Description}\relax
This function perform two tasks: (i) it generate the descriptive and change statistics of groups, particularly suited for the outputs form the \code{\LinkA{akmedoids.clust}{akmedoids.clust}} function, and (ii) generates the plots of the groups (performances).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
statPrint(clustr, traj, id_field = TRUE, bandw = 0.25,
  type = "lines", y.scaling = "fixed")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{clustr}] [vector (charater)] A vector of cluster membership (labels). For instance, the result extracted from the \code{\LinkA{akmedoids.clust}{akmedoids.clust}} function.

\item[\code{traj}] [matrix (numeric)]: corresponding longitudinal data used to generate \code{clustr} (with rows corresponding to each label of \code{clustr}). For example, the first label of \code{clustr} is the group label of the first row of \code{traj} matrix, and so on.

\item[\code{id\_field}] [numeric or character] Whether the first column of the \code{traj} is a unique (\code{id}) field. Default: \code{FALSE}. If \code{TRUE} the function recognises the second column as the first time step.

\item[\code{bandw}] [numeric] A small probability (quantile) value between \code{[0,1]} to partition the trajectories into three classes, i.e. \code{lower}, \code{central}, and the \code{uppper} classes. The middle of the \code{central} class is defined by the average slope of all trajectories. The upper and the lower limits of the \code{central} class is determined by the value of \code{bandw}. Default value is \code{0.25}, indicating that all slopes within 25th quantiles of the maximum slopes on both sides of the average slope are categorised as \code{central} class.

\item[\code{type}] [character] plot type. Available options are: \code{"lines"} and \code{"stacked"}.

\item[\code{y.scaling}] [character] works only if \code{type="lines"}. \code{y.scaling} set the vertical scales of the cluster panels. Options are: \code{"fixed"}: uses uniform scale for all panels, \code{"free"}: uses variable scales for panels.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Generates the descriptive and change statistics of the trajectory groupings. Given a vector of group membership (labels) and the corresponding data matrix (or data.frame) indexed in the same order, this function generates all the descriptive and change statistics of all the groups.
The function can generate a line and an area stacked plot drawing from the functionalities of the \code{ggplot2} library. For a more customised visualisation, we recommend that users deploy \code{ggplot2} directly (\code{Wickham H. (2016)}).
\end{Details}
%
\begin{Value}
A plot showing group membership or sizes (proportion) and statistics.
\end{Value}
%
\begin{References}\relax
\code{Wickham H. (2016). Elegant graphics for Data Analysis. Spring-Verlag New York (2016)}
\end{References}
%
\begin{Examples}
\begin{ExampleCode}
traj <- traj
print(traj)
traj <- dataImputation(traj, id_field = TRUE, method = 1, replace_with = 1,
fill_zeros = FALSE)
print(traj)
traj <- props(traj, id_field = TRUE)
clustr <- akmedoids.clust(traj, id_field = TRUE, method = "linear", k = c(3,6))
clustr <- as.vector(clustr$optimSolution)
print(statPrint(clustr, traj, id_field=TRUE, show.plot, show.stat, type="lines", y.scaling="fixed"))
print(statPrint(clustr, traj, id_field=TRUE, show.plot, show.stat, bandw = 0.30, type="stacked"))
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{traj}{Longitudinal dataset}{traj}
\keyword{datasets}{traj}
%
\begin{Description}\relax
Simulated longitudinal datasets with missing values (\code{NA}, \code{Inf}, \code{null})
\end{Description}
%
\begin{Usage}
\begin{verbatim}
traj
\end{verbatim}
\end{Usage}
%
\begin{Format}
A matrix
\end{Format}
\inputencoding{utf8}
\HeaderA{wSpaces}{Whitespaces removal}{wSpaces}
%
\begin{Description}\relax
This function removes all the leading and the trailing whitespaces in data
\end{Description}
%
\begin{Usage}
\begin{verbatim}
wSpaces(traj)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{traj}] [matrix (numeric)]: longitudinal data. Each row represents an individual trajectory (of observations). The columns show the observations at consecutive time points.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Given a matrix suspected to contain whitespaces, this function removes all the whitespaces and returns a cleaned data. ’Whitespaces’ are white characters often introduced into data during data entry, for instance by wrongly pressing the spacebar. For example, neither " A" nor "A " equates "A" because of the whitespaces that exist in them. They can also result from systematic errors in data recording devices.
\end{Details}
%
\begin{Value}
A matrix with all whitespaces (if any) removed.
\end{Value}
%
\begin{References}\relax
\url{https://en.wikipedia.org/wiki/Whitespace_character}
\end{References}
%
\begin{Examples}
\begin{ExampleCode}
traj <- traj
wSpaces(traj)
\end{ExampleCode}
\end{Examples}
\printindex{}
\end{document}
