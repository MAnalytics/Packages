
#' @title Cluster plotting
#' @description Function to plot the clusters generated by the \code{\link{akmeans.clust}} function
#' @param clustr A data.frame of cluster trajectories (e.g. an output of \code{\link{akmeans.clust}}), in which the last column represents alphabetical cluster ids (labels)
#' @param id_field Whether the first column is a unique (id) field. Default: \code{TRUE}.
#' @param y.scaling To set the vertical scales of the cluster panels. Options are: \code{"fixed"}: uses uniform scale for all panels, \code{"free"}: uses variable scales for panels.
#' @examples
#' traj <- gm.crime.sample1
#' print(traj) #
#' traj <- missingValue(traj, id_field = TRUE, method = 2, replace_with = 1,
#' fill_zeros = FALSE) #filling up the missing values
#' print(traj)
#' clusters <- akmeans.clust(traj, id_field = TRUE, init_method = "lpm", n_clusters = 5)
#' dev.new()
#' print(plotr(clusters, id_field=TRUE, y.scaling="free"))
#' @details Given a matrix or data.frame with some suspected outlier observations, this function identified those observations based on the method chosen and replace all the observations accordingly.
#' @return A plot showing clusters of trajectories, including the associated trendline - a linear trendline if clusters are based on \code{\link{lpm.centroids}} initialisation.
#' @keywords plot, clusters
#' @rawNamespace import(reshape2, ggplot2)
#' @references \code{Wickham H. (2016). Elegant graphics for Data Analysis. Spring-Verlag New York (2016)}
#' @export

plotr <- function(clustr, id_field=TRUE, y.scaling="fixed"){

  #check if 'id_field' is a unique field
  if(id_field==TRUE){
    n_CL <- colnames(clustr)[1]
    col_names <- as.vector(clustr[,1])
    if(!length(col_names)==length(unique(col_names))){
      stop("(: The 'id_field' is not a unique field. Function terminated!!! :)")
    }
  }

  if(id_field==FALSE){
    clustr <- cbind(1:nrow(clustr), clustr)  #head(clustr)
  }

  #cluster list
  clusters <- as.vector(clustr[,ncol(clustr)])

  #data
  data_subset <- clustr[,1:(ncol(clustr)-1)] #head(data_subset)
  colnames(data_subset) <- c("code", 1:(ncol(clustr)-2))

  data_subset <- as.data.frame(data_subset) #head(data_subset)

  data.subset.melted <- suppressWarnings(melt(data_subset, id="code"))  #head(data_subset.melted) #length(unique(data_subset$code)) #nrow(data_subset)

  #append cluster list
  data.subset.melted <- cbind(data.subset.melted, rep(clusters, ncol(data_subset)-1))#nrow(data.long.melted)

  ggplot <- aes <- Year <- value <- id <- geom_line <- facet_wrap <- geom_smooth <- theme_minimal <- NULL

  colnames(data.subset.melted) <- c("id","Year","value", "clusters")
  #plot
  if(y.scaling=="fixed"){
  p <- (ggplot(data.subset.melted, aes(x=Year, y=value,
                                     group=id), color="grey") +
        geom_line() +
        facet_wrap(~clusters, scales = "fixed") +
        geom_smooth(method="lm", aes(group=clusters), color="black", size=1) +
        theme_minimal()) #clusters
  }

  if(y.scaling=="free"){
  p <- (ggplot(data.subset.melted, aes(x=Year, y=value,
                                   group=id)) +

        geom_line() +
        facet_wrap(~clusters, scales = "free") +
        geom_smooth(method="lm", aes(group=clusters), color="black", size=1) +
        theme_minimal()) #clusters
 }

  return(p)
}
